# 20230317

## [30 | 编程范式游记（1）- 起源](https://time.geekbang.org/column/article/301)


一方面，我发现在一些语言争论上，有很多人对编程语言的认识其实并不深；另一方面，通过编程语言的范式，我们不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能，写出更好的代码。

编程范式的英语是 Programming Paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照“方法学”一词）。


那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些。


下面是一个使用了void*泛型版本的 swap 函数。


``` c

void swap(void* x, void* y, size_t size)
{
     char tmp[size];
     memcpy(tmp, y, size);
     memcpy(y, x, size);
     memcpy(x, tmp, size);
}
```

除了使用 void* 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示

``` c

#define swap(x, y, size) {\
  char temp[size]; \
  memcpy(temp, &y, size); \
  memcpy(&y,   &x, size); \
  memcpy(&x, temp, size); \
}
```

小结这里，如果说，程序 = 算法 + 数据，我觉得 C 语言会有这几个问题：一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或 宏替换的方式，这两种方式导致了类型过于宽松，并带来很多其它问题。适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。
算法其实是在操作数据结构，而数据则是放到数据结构中的，所以，真正的泛型除了适配数据类型外，还要适配数据结构，最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型；再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。
最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。

总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理底层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。C 语言把非常底层的控制权交给了程序员，它设计的理念是：
相信程序员；不会阻止程序员做任何底层的事；保持语言的最小和最简的特性；保证 C 语言的最快的运行速度，那怕牺牲移值性。
从某种角度上来说，C 语言的伟大之处在于——使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。这是 C 语言的强大和优雅之处。也有人说，C 语言是高级语言中的汇编语言。
不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶、更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务、更为抽象的语言。

说到这里，我想你会问，那 C 语言会怎么去解决这些问题呢？简单点说，C 语言并没有解决这些问题，所以才有了后面的 C++ 等其他语言，下一讲中，我也会和你聊聊 C++ 是如何解决这些问题的。

C 语言诞生于 1972 年，到现在已经有 45 年的历史，在它之后，C++、Java、C# 等语言前仆后继，一浪高过一浪，都在试图解决那个时代的那个特定问题。我们不能去否定某个语言，但可以确定的是，随着历史的发展，每一门语言都还在默默迭代，不断优化和更新。同时，也会有很多新的编程语言带着新的闪光耀眼的特性出现在我们面前。


如果说，程序 = 算法 + 数据，我觉得 C 语言会有这几个问题：一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或 宏替换的方式，这两种方式导致了类型过于宽松，并带来很多其它问题。适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。算法其实是在操作数据结构，而数据则是放到数据结构中的，所以，真正的泛型除了适配数据类型外，还要适配数据结构，最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型；再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理底层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。C 语言把非常底层的控制权交给了程序员，它设计的理念是：相信程序员；不会阻止程序员做任何底层的事；保持语言的最小和最简的特性；保证 C 语言的最快的运行速度，那怕牺牲移值性。从某种角度上来说，C 语言的伟大之处在于——使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。这是 C 语言的强大和优雅之处。也有人说，C 语言是高级语言中的汇编语言。不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶、更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务、更为抽象的语言。说到这里，我想你会问，那 C 语言会怎么去解决这些问题呢？简单点说，C 语言并没有解决这些问题，所以才有了后面的 C++ 等其他语言，下一讲中，我也会和你聊聊 C++ 是如何解决这些问题的。C 语言诞生于 1972 年，到现在已经有 45 年的历史，在它之后，C++、Java、C# 等语言前仆后继，一浪高过一浪，都

### 评论摘抄

### 403

```
斯坦福大学的编程范式公开课很好
```

## 固定片尾

此文单为3月Day06学习笔记, 内容来源于极客时间<<左耳听风>> <<SQL必知必会作>> <<TDD项目实战70讲>> 等, 强烈推荐该课程!