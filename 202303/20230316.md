# 20230316

## [45 | 弹力设计篇之“服务的状态”](https://time.geekbang.org/column/article/4086)

所谓“状态”，就是为了保留程序的一些数据或是上下文。比如之前幂等性设计中所说的需要保留每一次请求的状态，或是像用户登录时的 Session，我们需要这个 Session 来判断这个请求的合法性，还有一个业务流程中需要让多个服务组合起来形成一个业务逻辑的运行上下文 Context。这些都是所谓的状态。

一直以来，无状态的服务都被当作分布式服务设计的最佳实践和铁律。因为无状态的服务对于扩展性和运维实在是太方便了。
为了做出无状态的服务，我们通常需要把状态保存到其他的地方。比如，不太重要的数据可以放到 Redis 中，重要的数据可以放到 MySQL 中，或是像 ZooKeeper/Etcd 这样的高可用的强一致性的存储中，或是分布式文件系统中

而现在分布式数据库也开始将服务和存储分离，也是为了让自己的系统更有弹力。

而有状态的服务有这些好处。 数据本地化（Data Locality）。一方面状态和数据是本机保存，这方面不但有更低的延时，而且对于数据密集型的应用来说，这会更快。 更高的可用性和更强的一致性。也就是 CAP 原理中的 A 和 C。

为什么会这样呢？因为对于有状态的服务，我们需要对于客户端传来的请求，都必须保证其落在同一个实例上，这叫 Sticky Session 或是 Sticky Connection。这样一来，我们完全不需要考虑数据要被加载到不同的节点上去，
多系统的高可用的设计都会采取数据在运行时就复制的方案，比如：ZooKeeper、Kafka、Redis 或是 ElasticSearch 等等。在运行时进行数据复制就需要考虑一致性的问题，所以，强一致性的系统一般会使用两阶段提交。

这要求所有的节点都需要有一致的结果，这是 CAP 里的 CA 系统。而有的系统采用的是大多数人一致就可以了，比如 Paxos 算法，这是 CP 系统。

好了，我们来总结一下今天分享的主要内容。首先，我讲了无状态的服务。无状态的服务就像一个函数一样，对于给定的输入，它会给出唯一确定的输出。它的好处是很容易运维和伸缩，但需要底层有分布式的数据库支持。 接着，我讲了有状态的服务，它们通过 Sticky Session、一致性 Hash 和 DHT 等技术实现状态和请求的关联，并将数据同步到分布式数据库中；利用分布式文件系统，还能在节点挂掉时快速启动新实例

### 评论摘抄

#### mingshun

```
这是近几年所在的团队维护的其中一个重要系统的过程：最初为提高处理性能和水平扩展性，就从有状态往无状态发展。但随着数据量越来越大时，分布式存储就成了瓶颈，经常因为存储系统同步不及时导致不同节点读到的数据不一致。而后又回到有状态，但不在节点间使用分布式存储，因为数据量实在太大。为了在出现故障能快速恢复，每个节点做成双机热备。每改一次架构都要分好几次在周末深夜做数据迁移，多么痛的领悟啊！
理想情况下，计算密集型系统应该让存储向计算方移动，即做成无状态的；存储密集型系统应该让计算向存储移动，即做成有状态的。而上述架构来回修改的最终体会是，当计算和存储都密集的时候，应该整台机器地加，而且每台机器都要求有高的计算和存储性能。
然而说到底，存储其实又是由独立于CPU之外的一个计算单元来处理，本质似乎又回到了计算。现在设计分布式系统时总是先想着怎么分离计算和存储，最终发现计算和存储又是如此密不可分。
感觉我后半段的表述不太成立，打码久了不写人话的后果啊，望谅解！



## 固定片尾

此文单为3月Day06学习笔记, 内容来源于极客时间<<左耳听风>> <<SQL必知必会作>> <<TDD项目实战70讲>> 等, 强烈推荐该课程!