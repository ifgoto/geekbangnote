# 20230315

## [44 | 弹力设计篇之“幂等性设计](https://time.geekbang.org/column/article/4050?cid=100002201)

当然，更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做 PRG 模式（Post/Redirect/Get）

对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。 update table set status = “paid” where id = xxx and status = “unpaid”;

要做到这个事，我们需要一个存储来记录收到的交易。

在全局唯一 ID 的算法中，这里介绍一个 Twitter 的开源项目 Snowflake。它是一个分布式 ID 的生成算法。它的核心思想是，产生一个 long 型的 ID，其中： 41bits 作为毫秒数。大概可以用 69.7 年。 10bits 作为机器编号（5bits 是数据中心，5bits 的机器 ID），支持 1024 个实例。 12bits 作为毫秒内的序列号。一毫秒可以生成 4096 个序号。

为了解决分配冲突的问题，我们需要使用一个不会冲突的算法，比如使用 UUID 这样冲突非常小的算法。但 UUID 的问题是，它的字符串占用的空间比较大，索引的效率非常低，生成的 ID 太过于随机，完全不是人读的，而且没有递增，如果要按前后顺序排序的话，基本不可能。

决手段可以是超时后查询调用结果，也可以是在被调用的服务中实现幂等性。为了在分布式系统中实现幂等性，我们需要实现全局 ID。Twitter 的 Snowflake 就是一个比较好用的全局 ID 实现。最后，我给出了幂等性接口的处理流程。

而服务调用有三种结果：成功、失败和超时，其中超时是我们需要解决的问题。

在这种情况下，一般有两种处理方式。 一种是需要下游系统提供相应的查询接口。上游系统在 timeout 后去查询一下。如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。 另一种是通过幂等性的方式。也就是说，把这个查询操作交给下游系统，我上游系统只管重试，下游系统保证一次和多次的请求结果是一样的。

所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x) = f(f(x))。

好了，我们来总结一下今天分享的主要内容。首先，同步调用有四个问题：影响吞吐量、消耗系统资源、只能一对一，以及有多米诺骨牌效应。于是，我们想用异步调用来避免该问题。


## 固定片尾

此文单为3月Day06学习笔记, 内容来源于极客时间<<左耳听风>> <<SQL必知必会作>> <<TDD项目实战70讲>> 等, 强烈推荐该课程!