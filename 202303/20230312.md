# 20230312

## 41 | [弹力设计篇之“认识故障和弹力设计](https://time.geekbang.org/column/article/3912)

MTTF 是 Mean Time To Failure，平均故障前的时间，即系统平均能够正常运行多长时间才发生一次故障。系统的可靠性越高，MTTF 越长。（注意：从字面上来说，看上去有 Failure 的字样，但其实是正常运行的时间。） MTTR 是 Mean Time To Recovery，平均修复时间，即从故障出现到故障修复的这段时间，这段时间越短越好。

Availbility = MTTF/(MTTF+MTTR)

MTTR 才是我们能努务的方向

对于分布式系统的容错设计，在英文中又叫 Resiliency（弹力）。意思是，系统在不健康、不顺，甚至出错的情况下有能力 hold 得住，挺得住，还有能在这种逆境下力挽狂澜的能力。


如果你在云平台上，或者使用了“微服务”，面对大量的 IoT 设备以及不受控制的用户流量，那么系统故障会更为复杂和变态。因为上面这些因素增加了整个系统的复杂度。 所以，要充分地意识到下面两个事。 故障是正常的，而且是常见的。 故障是不可预测突发的，而且相当难缠。 所以，亚马逊的 AWS 才会把 `Design for Failure `作为其七大 Design Principle 的重点。这告诉我们，不要尝试着去避免故障，而是要把处理故障的代码当成正常的功能做在架构里写在代码里。 因为我们要干的事儿就是想尽一切手段来降低 MTTR——故障的修复时间。

一方面，在好的情况下，这个事对于我们的用户和内部运维来说是完全透明的，系统自动修复不需要人的干预。 另一方面，如果修复不了，系统能够做自我保护，而不让事态变糟糕。

## [SQL必知必会作者相关github](https://github.com/cystanford)

nothing

## [01 | 学编辑器，到底应该学什么？](https://time.geekbang.org/column/article/24245?cid=100016901&screen=full)

在我看来，编辑器的学习，和编程语言有一点类似。你当然可以找一本官方手册，从头到尾事无巨细全部学习一遍，这里面包括基本语法、数据类型、控制结构、函数、设计模式、框架等等。一开始在你不熟悉这门编程语言的时候，你可能会陷入到某一个语法的细节里很久不能自拔，但最后等你掌握了之后，你才发现，当初自学时自己纠结的点根本不影响大局，那些你当初认为重要的细节其实一点不那么重要。 在掌握了第一门编程语言之后，你想要学习另外一门新的编程语言，如果这个时候，你的学习路径还像学习第一门编程语言时那样，那我可以武断地说，你并没有从全局上理解这门编程语言，也没有在脑海中建立起“学习框架”。
其实编程语言在设计上大同小异，新的编程语言往往都是在解决老的语言的某一个短板，但他们在最本质的设计上不会有大的变化。在有了这个框架之后，你再去学习，就不至于“拣了芝麻丢了西瓜”了。
当使用一个工具时，你关心的应该是它能用来做什么，它最擅长做什么，以及它做不了什么，换句话说，就是这个工具的“下限”和“上限”。
首先，我们一起来找下编辑器或者 IDE 的“下限”。一款开发工具的“下限”是由它默认自带的功能决定的，也就是它开箱即用时的体验。对于大部分用户而言，工具的“下限”也就决定了他们会不会马上卸载它。
除了看系统上的惯用快捷键，开发工具之间也会互相参考。最后，也是最重要的一点，我们要看快捷键的配置是否有统一性。Shift 键能用于控制文本选择的，Ctrl 或者 Cmd 键能当做辅助键的，Tab 是用于在控件之间跳转的……也就是说，如果编辑器在选择快捷键的时候使用了某些规则，那么就要坚定地贯彻下去，否则就会给用户带来困扰。
我们先从编辑器开发者的角度来看这个点。一般来说，编辑器的开发者要尽可能保证这些快捷键的默认配置接近大家的使用习惯。比如 VS Code 在给新功能选择快捷键时，会先看看系统是不是有类似的功能，以及系统用的是哪个快捷键组合。
你还要试着找出快捷键的分类方式。毕竟功能总是比键帽的数量多，所以能够把这么多功能映射成快捷键本身就是门学问，了解了这门学问后，你再来掌握所用编辑器的快捷键，就会轻松很多。
Vim 都快 30 岁了，现在哪个开发工具要是说没法支持 Vim 的操作方式，那真的会相形见绌。投资一种高效的快捷键操作，花点时间让它成为你的肌肉记忆，然后用 30 年，这样你的整个职业生涯都会受益。
编程语言与框架支持
因此，当你去考察一个新的编辑器时，就需要看它对你必须使用的编程语言的支持情况如何，语法高亮是否正确，是否有自动补全功能，能否直接调试和运行测试。你甚至需要研究怎么让它支持你电脑上特殊的环境变量，怎么更好地和你们使用的框架集成，这些就是你要付出的学习成本。
对工作流的选择和支持
最后一个影响因素，就是编辑器对工作流的选择和支持。工作流的选择，既是态度，又非常能够体现时代背景和行业现状。
说完“下限”，我们再接着来说说编辑器的“上限”。如果编辑器支持用户写插件来定制功能，那它的“上限”就很高了。像 Emacs、Eclipse 和 Atom 这样允许修改任意功能的工具来说，它们的“上限”理论上是无限的。但扩展编辑器这个事情，由于最终还是要落实到社区和个人，真正能达到的高度就很难说了。
面我说了很多关于编辑器“上限”和“下限”，其实这也就是我学习新编辑器时会着重研究的方向。在研究时，其实我有个“三步走”的演变过程，也就是极客时间团队提到的学习路径： 最开始的时候，我特别关心快捷键和语言支持，在这上面花了很多时间，这个过程就像是打怪升级，不断更新自己的装备库； 再往后，我就会开始挑剔编辑器的其他组件，但凡是跟自己的工作习惯或者工作流不匹配的，就会想办法换掉它，这是个做减法的过程； 最后一步，就是自己学习写插件了，编辑器本身的功能和社区不能够完全满足自己的需求，本着“麻烦别人不如磨炼自己”的精神，我开始自己动手。
当然，一个人的兴趣点和精力都是有限的，任何事都没办法一蹴而就，因此有的放矢才是精进的关键。 我的建议是这样的，快捷键的学习是值得多花时间的；语言的支持方面，如果你是初学者，我不太建议使用一款什么都得自己配置的编辑器，把时间放在这上面不太划算（通常来说，语言或者框架作者推荐啥我就先用啥，等经验丰富了，再去研究那些更灵活的编辑器，才更游刃有余）；至于工作流这块，选择“有态度的”编辑器可能会更好一些，一款流行且社区活跃的编辑器推崇的工作流，大概率上是经得起工程上的考验的。 而插件开发的学习，既可以当做语言的学习，也能够当做业余项目，还能够锻炼跟社区的沟通能力，每个人都值得尝试。我在开发 VS Code 和一些插件的时候，就认识了不少朋友，这些人都非常优秀，也一直激励和影响着现在的我。
当然，学习没有捷径，最重要的永远是立刻动手。

## [02 | VS Code的Why、How和What](https://time.geekbang.org/column/article/29948?screen=full)

官方定义它是一个免费的、开源的跨平台编辑器。之所以强调“编辑器”，我想是因为 VS Code 并无意成为一个全尺寸的集成开发环境，也就是 IDE。

VS Code 的全称是 Visual Studio Code，但这全名实在是太长了，我和很多用户一样，喜欢叫它 VS Code

IDE 更为关注开箱即用的编程体验、对代码往往有很好的智能理解，同时侧重于工程项目，为代码调试、测试、工作流等都有图形化界面的支持，因此相对笨重，Java 程序员常用的 Eclipse 定位就是 IDE；而编辑器则相对更轻量，侧重于文件或者文件夹，语言和工作流的支持更丰富和自由，VS Code 把自己定位在编辑器这个方向上，但又不完全局限于此。

不管你是学习编程语言，还是框架、编辑器，都应该先去看看它的来龙去脉，了解它们是怎么发展而来的，曾经遇到了什么问题，又是怎么解决的，这些信息都便于你从大局上提高对事情本质的认识。

2011 年底，微软从 IBM 请来了 Erich Gamma。Erich Gamma 是《设计模式》一书的作者之一，曾和肯特·贝克（Kent Beck） 一起发明了 JUnit，并且在 IBM 领导 Java 开发工具的开发工作。微软把他请过来，就是希望他能够打造一款在线的开发工具，让开发者们能够在浏览器里获得 IDE 般的开发体验，这也就是之后为人所知的 Monaco Editor

2015 年，Erich Gamma 带领团队把 Monaco Editor 移植到桌面平台上，也就是这个专栏的主角 Visual Studio Code，即 VS Code。 VS Code 继承了 Monaco Editor 的设计原则，其核心是做一个高性能的轻量级编辑器；个性化的功能，则交给插件系统来完成。这一点可以说是师承 Eclipse，但同时又吸取了 Eclipse 的教训，把插件系统运行在主进程之外，高度可定制但同时又是可控的。

VS Code 也有自己的使命，那就是让开发者在编辑器里拥有 IDE 那样的开发体验，比如对源代码有智能的理解、图形化的调试工具、版本管理等等。 不难发现，VS Code 希望在编辑器和 IDE 之间找到一个平衡。在这样的设计思路下，你打开编辑器，不需要创建任何的项目工程文件就可以开始使用，并高效便捷地操作文本；同时在编程语言插件的支持下能够得到语法检查、智能提示；你还可以借助丰富的插件 API 拓展 VS Code 以满足自己的需求

Rust 的语言支持，就是由 Rust 官方团队开发和维护的，他们可以说是这个世界上最懂怎么给 Rust 做语法支持的一群人了。

把专业的事情交给专业的人来做。为此，VS Code 为编程语言工作者提供了统一的 API ，即 Language Server Protocol 和 Code Debugging Protocol，每种语言都能够通过实现两个 API 在 VS Code 上得到类似 IDE 的开发和调试体验。

其实我今天聊到的 why、how 和 what 也是一个经典的问题思考模型，外界称之为黄金圆环法

开源与开放的平台 首先，VS Code 的源代码以 MIT 协议开源。这不仅意味着大家能够免费获取到 VS Code 的核心代码，更意味着社区能够基于 VS Code 的代码，开发自己的产品。 业界现在比较知名的基于 VS Code 的项目有 SourceGraph、StackBlitz、CodeSandbox 等，这些产品可以提供非常接近 VS Code 的开发体验，而 VS Code 也经常从它们身上吸取技术和产品层面的宝贵经验。

其次，开发过程和反馈渠道的开放。 VS Code 源代码托管在 GitHub 上，同时使用 GitHub 管理项目的开发计划和测试，每个用户都可以在 GitHub 上了解到 VS Code 的开发进度。与此同时，GitHub 也是 VS Code 唯一的反馈渠道，开发团队根据反馈的影响程度进行统筹安排。作为用户，你可以近乎实时地跟开发团队进行交流，了解产品的发展情况。

再次，接口的开放。VS Code 自带了 TypeScript 和 Node.js 的支持，用户下载 VS Code 后，立刻就能够在书写 JavaScript 和 TypeScript 时获得智能提示，而且无需任何配置即可立即调试 Node.js 代码。VS Code 核心团队有 Node.js 高手，TypeScript 也是微软官方出品的，VS Code 能把对这两个语言的支持做好，似乎并不是什么值得惊讶的事情。但是 VS Code 团队不可能精通所有语言，对于他们不熟悉的语言，VS Code 该怎么支持呢？

我在第一讲 “学编辑器，到底应该‘学’什么？” 里讲过编辑器学习的通用办法，在 VS Code 身上也是适用的。你可以按照以下三个步骤来逐步掌握 VS Code。 核心编辑器的使用。VS Code 有一套自己的快捷键，你可以通过快捷键的学习了解核心编辑器所支持的功能。同时， VS Code 允许自定义快捷键的映射，如果你有自己熟悉的一套快捷键操作，也可以无缝地在 VS Code 上使用。除了快捷键，VS Code 对鼠标操作、多光标、搜索都有完备的支持；在编程语言的支持上面，VS Code 也向 IDE 看齐，自动补全、代码片段等一应俱全。掌握了核心编辑器，VS Code 就能够胜任你的日常通用编辑器。 工作台、工作区的使用。VS Code 中除了编辑器区域，还有很多其他的功能，像是资源管理器、跨文件搜索、插件管理等，它们一起组成了统一的界面，我们称之为工作台。这个工作台的设计，代表了 VS Code 对工作流的选择。内置的软件版本管理，终端模拟器，调试器等，掌握这些 VS Code “钦定”的工具，进一步提升工作效率。 VS Code 定制和插件开发。作为一个百万级别用户量的工具，很多功能的默认设置不可能满足每个人或者每个工作场景，你可以学习如何定制 VS Code 的各个部件，不能永远按部就班；对于 VS Code 没有实现的功能，还可以学习一下如何使用 JavaScript 书写插件，把自己的想法，变成工具的一部分。 通过这三个步骤，你在使用 VS Code 时就能够“随心所欲”了。除此之外，我也建议你关注 VS Code 每月的发布更新日志，官方团队会详细讲解每个版本新增的功能。VS Code 的官方博客也非常值得订阅，团队成员会经常分享开发过程的心得感悟，算得上是最前沿的技术分享。


## [15丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？](https://time.geekbang.org/column/article/107401?screen=full)


关于几个隔离级别, 还是有点乱, 
拿`MySql`来说, 官方的还是[15.7.2.1 Transaction Isolation Levels](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)

其中 关于 后面不验读锁的一段需要花更多的时间去确认.

```
Note
As of MySQL 8.0.22, DML operations that read data from MySQL grant tables (through a join list or subquery) but do not modify them do not acquire read locks on the MySQL grant tables, regardless of the isolation level. For more information, see Grant Table Concurrency.
```

再者, 中文来说可以看 `廖雪峰的sql教程`中的[事务](https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848)中的一段, 
而本文中, 作者(陈旸)举的例子好像并不太过好理解.



我还是以廖的文章为主好了

### [事务](https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848)

在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：

-- 从id=1的账户给id=2的账户转账100元
-- 第一步：将id=1的A账户余额减去100
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 第二步：将id=2的B账户余额加上100
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。

这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。

可见，数据库事务具有ACID这4个特性：

A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；
C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；
I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；
D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。
对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。

要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务，例如，把上述的转账操作作为一个显式事务：

BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。

COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。

有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：

BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
ROLLBACK;
数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。

隔离级别
对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。

SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：

|Isolation Level|脏读（Dirty Read）|不可重复读（Non Repeatable Read）|幻读（Phantom Read）|
|-|-|-|-|
|Read Uncommitted|	Yes	           |Yes                             |Yes|
|Read Committed	|-	                |Yes                            |Yes|
|Repeatable Read|-                  |	-	                        |Yes
|Serializable	|-	                |-                              |-|

我们会依次介绍4种隔离级别的数据一致性问题。

小结
数据库事务具有ACID特性，用来保证多条SQL的全部执行。

下面开始的一个细节 就是`autocommit = 0`

#### Read Uncommitted

是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。

我们来看一个例子。

首先，我们准备好students表的数据，该表仅一行记录：

mysql> select * from students;
+----+-------+
| id | name  |
+----+-------+
|  1 | Alice |
+----+-------+
1 row in set (0.00 sec)
然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：

|时刻	|事务A	        |事务B|
|-|-|-|
|1	|SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;	|SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;|
|2	|BEGIN;	            |BEGIN;|
|3	|UPDATE students SET name = 'Bob' WHERE id = 1;	||
|4	|	            |SELECT * FROM students WHERE id = 1;||
|5	|ROLLBACK;	||
|6	|               |	SELECT * FROM students WHERE id = 1;|
|7	|               |	COMMIT;|

当事务A执行完第3步时，它更新了id=1的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。
随后，事务A在第5步进行了回滚，事务B再次读取id=1的记录，发现和上一次读取到的数据不一致，这就是脏读。
可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。

#### Read Committed

在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。

不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。

我们仍然先准备好students表的数据：

mysql> select * from students;
+----+-------+
| id | name  |
+----+-------+
|  1 | Alice |
+----+-------+
1 row in set (0.00 sec)
然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：

|时刻|事务A                             |事务B
|-|-|-|
|1|SET TRANSACTION ISOLATION LEVEL READ COMMITTED;|SET TRANSACTION ISOLATION LEVEL READ COMMITTED;|
|2|BEGIN;                               | BEGIN;|
|3|                                     |SELECT * FROM students WHERE id = 1; -- Alice|
|4|	UPDATE students SET name = 'Bob' WHERE id = 1;	||
|5|	COMMIT;	                            |
|6|		                                |SELECT * FROM students WHERE id = 1; -- Bob
|7|                                      |COMMIT;|

当事务B第一次执行第3步的查询时，得到的结果是Alice，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了Bob，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。


#### Repeatable Read

在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。

幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。

我们仍然先准备好students表的数据：

mysql> select * from students;
+----+-------+
| id | name  |
+----+-------+
|  1 | Alice |
+----+-------+
1 row in set (0.00 sec)
然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：

|时刻	|事务A	                                |事务B|
|-|-|-|
|1|	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;|	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;|
|2 |BEGIN;	                                |BEGIN;|
|3	|	                                    |SELECT * FROM students WHERE id = 99; -- empty|
|4	|INSERT INTO students (id, name) VALUES (99, 'Bob');	||
|5	|COMMIT;	||
|6	| |SELECT * FROM students WHERE id = 99; -- empty|
|7	| |	UPDATE students SET name = 'Alice' WHERE id = 99; -- 1 row affected|
|8	|  |	SELECT * FROM students WHERE id = 99; -- Alice|
|9	|   |	COMMIT;|
|

事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。

可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。

#### Serializable

Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。

虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。

默认隔离级别
如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。


### 下面开始才是本次geektime的笔记

我们还需要降低数据库的隔离标准，来换取事务之间的并发能力。

有时候我们需要牺牲一定的正确性来换取效率的提升，也就是说，我们需要通过设置不同的隔离等级，以便在正确性和效率之间进行平衡。

实际上，SQL-92 标准中已经对 3 种异常情况进行了定义，这些异常情况级别分别为脏读（Dirty Read）、不可重复读（Nonrepeatable Read）和幻读（Phantom Read）。

我来总结下这三种异常情况的特点： 脏读：读到了其他事务还没有提交的数据。 不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。 幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。

脏读、不可重复读和幻读这三种异常情况，是在 SQL-92 标准中定义的，同时 SQL-92 标准还定义了 4 种隔离级别来解决这些异常情况。 解决异常数量从少到多的顺序（比如读未提交可能存在 3 种异常，可串行化则不会存在这些异常）决定了隔离级别的高低，这四种隔离级别从低到高分别是：读未提交（READ UNCOMMITTED ）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和可串行化（SERIALIZABLE）。这些隔离级别能解决的异常情况如下表所示：

我们今天只是简单讲解了 4 种隔离级别，以及对应的要解决的三种异常问题。我会在优化篇这一模块里继续讲解隔离级别以及锁的使用。 你能看到，标准的价值在于，即使是不同的 RDBMS 都需要达成对异常问题和隔离级别定义的共识。这就意味着一个隔离级别的实现满足了下面的两个条件： 正确性：只要能满足某一个隔离级别，一定能解决这个隔离级别对应的异常问题。 与实现无关：实际上 RDBMS 种类很多，这就意味着有多少种 RDBMS，就有多少种锁的实现方式，因此它们实现隔离级别的原理可能不同，然而一个好的标准不应该限制其实现的方式。 隔离级别越低，意味着系统吞吐量（并发程度）越大，但同时也意味着出现异常问题的可能性会更大。在实际使用过程中我们往往需要在性能和正确性上进行权衡和取舍，没有完美的解决方案，只有适合与否。

实际上，SQL-92 标准中已经对 3 种异常情况进行了定义，这些异常情况级别分别为脏读（Dirty Read）、不可重复读（Nonrepeatable Read）和幻读（Phantom Read）。

我来总结下这三种异常情况的特点： 脏读：读到了其他事务还没有提交的数据。 不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。 幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。 事务隔离的级别有哪些？

读未提交（READ UNCOMMITTED ）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和可串行化（SERIALIZABLE）

读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于 RDBMS 中常见的默认隔离级别（比如说 Oracle 和 SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在 SQL 查询的时候编写带加锁的 SQL 语句（我会在进阶篇里讲加锁）。




```

docker run --name mysqldb -p 3306:3306 -v /c/docker/mysql/8/config:/etc/mysql/conf.d -v /c/docker/mysql/8/data:/var/lib/mysql -v /c/docker/mysql/8/log:/var/log/mysql -e MYSQL_ROOT_PASSWORD=123456 -e TZ=Asia/Shanghai -d mysql

```

## 固定片尾

此文单为3月Day06学习笔记, 内容来源于极客时间<<左耳听风>> <<SQL必知必会作>> <<TDD项目实战70讲>> 等, 强烈推荐该课程!