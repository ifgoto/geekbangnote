# 20230314

## [43 | 弹力设计篇之“异步通讯设计”](https://time.geekbang.org/column/article/3926?screen=full)

异步通讯的设计重点 首先，我们需要知道，为什么要异步通讯。 异步通讯最重要的是解耦服务间的依赖。最佳解耦的方式是通过 Broker 的机制。 解耦的目的是让各个服务的隔离性更好，这样不会出现“一倒倒一片”的故障。 异步通讯的架构可以获得更大的吞吐量，而且各个服务间的性能不受干扰相对独立。 利用 Broker 或队列的方式还可以达到把抖动的吞吐量变成均匀的吞吐量，这就是所谓的“削峰”，这对后端系统是个不错的保护。 服务相对独立，在部署、扩容和运维上都可以做到独立不受其他服务的干扰。 但我们需要知道这样的方式带来的问题，所以在设计成异步通信的时候需要注意如下事宜。 用于异步通讯的中间件 Broker 成为了关键，需要设计成高可用不丢消息的。另外，因为是分布式的，所以可能很难保证消息的顺序，因此你的设计最好不依赖于消息的顺序。 异步通讯会导致业务处理流程不那么直观，因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。 因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。


异步调用有三种方式：请求响应、直接订阅和中间人订阅。最后，我介绍了事件驱动设计的特点和异步通讯设计的重点。

这样的设计常见于银行的对账程序，银行系统会有大量的外部系统通讯，比如跨行的交易、跨企业的交易，等等。所以，为了保证整体数据的一致性，或是避免漏处理及处理错的交易，需要有对账系统，这其实就是那个总控，这也是为什么银行有的交易是 T+1（隔天结算），就是因为要对个账，确保数据是对的。

必须是高可用的，因为它成了整个系统的关键； 必须是高性能而且是可以水平扩展的； 必须是可以持久化不丢数据的。

你知道，分布式系统的服务设计是需要向无状态服务（Stateless）努力的，这其中有太多的好处，无状态意味着你可以非常方便地运维。所以，事件通讯成为了异步通讯中最重要的一个设计模式。

同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。

通讯一般来说分同步和异步两种。同步通讯就像打电话，需要实时响应，而异步通讯就像发邮件，不需要马上回复。各有千秋，我们很难说谁比谁好。但是在面对超高吞吐量的场景下，异步处理就比同步处理有比较大的优势了，这就好像一个人不可能同时接打很多电话，但是他可以同时接收很多的电子邮件一样。

话，需要实时响应，而异步通讯就像发邮件，不需要马上回复。各有千秋，我们很难说谁比谁好。但是在面对超高吞吐量的场景下，异步处理就比同步处理有比较大的优势了，这就好像一个人不可能同时接打很多电话，但是他可以同时接收很多的电子邮件一样

43 | 弹力设计篇之“异步通讯设计”

## [java零基础学习](https://time.geekbang.org/course/detail/100027801-95611)

```
臧萌老师，能讲一下float和double的精度问题吗，还有它们的比较与计算？
作者回复: 浮点数的精度涉及到浮点数本身的表示形式，理解起来还是略复杂的。简化版大概可以这么理解，在浮点数的世界里，一个具体的二进制的数字，其实表示的是一个范围，比如说下面的三行代码：
        System.out.println(Double.toHexString(0.00000000000000000000000000000000000100000000000000021));
        System.out.println(Double.toHexString(0.00000000000000000000000000000000000100000000000000022));
        System.out.println(Double.toHexString(0.00000000000000000000000000000000000100000000000000032));

它们的输出是一样的
0x1.54484932d2e74p-120
0x1.54484932d2e74p-120
0x1.54484932d2e74p-120

这个意思是这三个数字，转换成浮点数的二进制后其实是一样的。这就是浮点数的精度的直观感受——非常相近的数字，二进制的表示形式是一样的。

就好像电子的轨道一样，不是说电子可以在任意轨道绕着原子核旋转，或者跃迁，光电效应了解一下？电子的轨道只能在固定的满足某个条件的轨道转圈。计算机也一样，不能表示无限精度的数字，只能尽力……
       
System.out.println(0.00000000000000000000000000000000000100000000000000032 == 0.00000000000000000000000000000000000100000000000000022);
比较也是一样的，正因为浮点数的这种不精确，导致其进行精确的比较是不可靠的，比如上面这两个不一样的数字，其实转换成二进制其实是一样的。输出的结果是true

同样的道理，这种不精确可能会积累，放大，所以浮点数的比较运算，比较推荐的是，求两个数字的差，然后让这个差取绝对值，和一个小到对业务没有影响的值比较，如果比这个值还小，就认为两个浮点数是相等的。
```


## 固定片尾

此文单为3月Day06学习笔记, 内容来源于极客时间<<左耳听风>> <<SQL必知必会作>> <<TDD项目实战70讲>> 等, 强烈推荐该课程!