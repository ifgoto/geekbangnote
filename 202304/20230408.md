# 20230408


## [59 | 性能设计篇之“异步处理”](https://time.geekbang.org/column/article/7036)

这就是异步系统所带来的好处——让我们的系统可以统一调度。


所谓 Push 推模型，就是把任务派发给相应的人去处理，有点像是一个工头的调度者的角色。而 Pull 拉模型，则是由处理的人来拉取任务处理。这两种模型各有各的好坏。一般来说，Push 模型可以做调度，但是它需要知道下游工作结点的情况。

而 Pull 的好处则是可以让上游结点不用关心下游结点的状态，只要自己忙得过来，就会来拿任务处理，这样可以减少一定的复杂度，但是少了整体任务调度。


最重要的是，异步处理 + 事件溯源的方式，可以很好地让我们的整个系统进行任务的统筹安排、批量处理，可以让整体处理过程达到性能和资源的最大化利用。

是的，你可以看到，我们的现实世界中有很多这样先付钱，拿小票去领货的场景，也有先消费，然后拿一个账单去付钱的场景。总之，完全不需要两阶段提交这种方式。我们完全可以使用异步的方式来达到一致性，当然，是最终一致性。

异步处理可能会因为一些故障导致我们的一些任务没有被处理，比如消息丢失，没有通知到，或通知到了，没有处理。有这一系列的问题，异步通知的方式需要任务处理方处理完成后，给任务发起方回传状态

 在运维时，我们要监控任务队列里的任务积压情况。如果有任务积压了，要能做到快速地扩容。如果不能扩容，而且任务积压太多，可能会导致整个系统挂掉，那么就要开始对前端流量进行限流。


最后，还想强调一下，异步处理系统的本质是把被动的任务处理变成主动的任务处理，其本质是在对任务进行调度和统筹管理。小结


首先，我介绍了异步通讯，它在弹力设计中的作用是提高系统的稳定性和容错能力，而其实我们还可以在异步通讯的基础上统筹任务来提高系统的吞吐量。接着，我讲了异步通讯的设计，包括推拉结合的模型。异步处理配合事件溯源一起使用，将大大简化 bug 修复后的数据恢复，也能用于实现存储的事务一致性。

我将餐馆吃饭作为比喻，介绍了异步处理的事务一致性一般不是强一致性，而是最终一致性，这样才能取得高的吞吐量。最后，我指出了异步处理的设计要点


### comment  


#### escray

```
异步处理一般需要缓存或者队列来协助，统一调度，更好的利用时间和资源，从而比同步处理更快。

异步处理需要一个前台系统，记录用户请求（日志或队列）；
还需要一个任务派发器，可以采用推拉结合的方式，Push 端做一定的任务调度，Pull 端订阅异步消息；
最后，需要任务处理系统真正处理请求。

事件溯源 Event Sourcing，系统没有状态，事件不可变，并且可使用之追加操作进行存储。

事件是描述已发生操作的简单对象，以及描述事件代表的操作所需的相关数据。

专栏并没有详细说明异步处理中的事件驱动，似乎这一类的文章也比较多。

异步处理需要任务处理方处理完成后，给任务发起方回传状态；
发起方需要有定时任务，把一些超时没有回传状态的任务重新做一遍；
如果回滚，需要补偿事务流程；
运维需要监控任务队列里面任务积压情况，如果需要，可能限流。

异步处理系统的本质是把被动的任务处理编程主动的任务处理，对任务进行调度和统筹管理。

现实生活中，需要用到强一致性的场景不多；绝大多数业务场景都用不到强一致性。

顺着专栏里面的链接去看了那个 Event-Sourcing + CQRS example application，没有看代码，然后看了 Chris Richardson 的会议演讲 PPT。

有一点好奇，代码的更新大概是在 2017 年，演讲大概是 2015 年之前，然后呢？
2023-03-28归属地：北京

```
#### 颇忒妥
```
Event sourcing 需要snapshot 否则启动时每次回放日志太恐怖。
如果要自制分布式系统可以看一下atomix项目
作者回复: 是的，要做snapshot 
```

## 固定片尾

此文单为4月学习笔记, 内容来源于极客时间<<左耳听风>> <<SQL必知必会作>> <<TDD项目实战70讲>> 等, 强烈推荐该课程!